Executing SQL file: extract-search-functions.sql
                                            pg_get_functiondef                                            
----------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.search_songs(p_query text, p_max_results integer DEFAULT 10)          +
  RETURNS TABLE(song_id uuid, song_title text, song_slug text, match_score integer, times_played integer)+
  LANGUAGE plpgsql                                                                                       +
 AS $function$                                                                                           +
 BEGIN                                                                                                   +
   RETURN QUERY                                                                                          +
   WITH search_matches AS (                                                                              +
     SELECT                                                                                              +
       s.id,                                                                                             +
       s.title,                                                                                          +
       s.slug,                                                                                           +
       ts_rank(s.search_vector, plainto_tsquery('english', p_query)) as fts_rank,                        +
       similarity(s.search_text, p_query) as trgm_sim,                                                   +
       CASE                                                                                              +
         WHEN LOWER(s.title) = LOWER(p_query) THEN 1.0                                                   +
         WHEN LOWER(s.title) LIKE LOWER(p_query) || '%' THEN 0.9                                         +
         WHEN LOWER(s.title) LIKE '%' || LOWER(p_query) || '%' THEN 0.8                                  +
         ELSE 0                                                                                          +
       END as exact_score,                                                                               +
       s.times_played                                                                                    +
     FROM songs s                                                                                        +
     WHERE                                                                                               +
       s.search_vector @@ plainto_tsquery('english', p_query)                                            +
       OR similarity(s.search_text, p_query) > 0.2                                                       +
       OR LOWER(s.title) LIKE '%' || LOWER(p_query) || '%'                                               +
   )                                                                                                     +
   SELECT                                                                                                +
     id,                                                                                                 +
     title::TEXT,                                                                                        +
     slug::TEXT,                                                                                         +
     GREATEST(                                                                                           +
       exact_score * 100,                                                                                +
       fts_rank * 60,                                                                                    +
       trgm_sim * 100                                                                                    +
     )::INTEGER as score,                                                                                +
     search_matches.times_played                                                                         +
   FROM search_matches                                                                                   +
   ORDER BY score DESC, search_matches.times_played DESC                                                 +
   LIMIT p_max_results;                                                                                  +
 END;                                                                                                    +
 $function$                                                                                              +
 
(1 row)

                                                                        pg_get_functiondef                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.search_venues(p_query text, p_max_results integer DEFAULT 10)                                                                  +
  RETURNS TABLE(venue_id uuid, venue_name text, venue_slug text, venue_city text, venue_state text, venue_country text, match_score integer, times_played integer)+
  LANGUAGE plpgsql                                                                                                                                                +
 AS $function$                                                                                                                                                    +
 BEGIN                                                                                                                                                            +
   RETURN QUERY                                                                                                                                                   +
   WITH search_matches AS (                                                                                                                                       +
     SELECT                                                                                                                                                       +
       v.id,                                                                                                                                                      +
       v.name,                                                                                                                                                    +
       v.slug,                                                                                                                                                    +
       v.city,                                                                                                                                                    +
       v.state,                                                                                                                                                   +
       v.country,                                                                                                                                                 +
       ts_rank(v.search_vector, plainto_tsquery('english', p_query)) as fts_rank,                                                                                 +
       similarity(v.search_text, p_query) as trgm_sim,                                                                                                            +
       CASE                                                                                                                                                       +
         WHEN LOWER(v.name) = LOWER(p_query) THEN 1.0                                                                                                             +
         WHEN LOWER(v.name) LIKE LOWER(p_query) || '%' THEN 0.9                                                                                                   +
         WHEN LOWER(v.name) LIKE '%' || LOWER(p_query) || '%' THEN 0.8                                                                                            +
         WHEN LOWER(v.city) = LOWER(p_query) THEN 0.7                                                                                                             +
         WHEN LOWER(v.city) LIKE '%' || LOWER(p_query) || '%' THEN 0.6                                                                                            +
         ELSE 0                                                                                                                                                   +
       END as exact_score,                                                                                                                                        +
       v.times_played                                                                                                                                             +
     FROM venues v                                                                                                                                                +
     WHERE                                                                                                                                                        +
       v.search_vector @@ plainto_tsquery('english', p_query)                                                                                                     +
       OR similarity(v.search_text, p_query) > 0.2                                                                                                                +
       OR LOWER(v.name) LIKE '%' || LOWER(p_query) || '%'                                                                                                         +
       OR LOWER(v.city) LIKE '%' || LOWER(p_query) || '%'                                                                                                         +
   )                                                                                                                                                              +
   SELECT                                                                                                                                                         +
     id,                                                                                                                                                          +
     name::TEXT,                                                                                                                                                  +
     slug::TEXT,                                                                                                                                                  +
     city::TEXT,                                                                                                                                                  +
     state::TEXT,                                                                                                                                                 +
     country::TEXT,                                                                                                                                               +
     GREATEST(                                                                                                                                                    +
       exact_score * 100,                                                                                                                                         +
       fts_rank * 60,                                                                                                                                             +
       trgm_sim * 100                                                                                                                                             +
     )::INTEGER as score,                                                                                                                                         +
     search_matches.times_played                                                                                                                                  +
   FROM search_matches                                                                                                                                            +
   ORDER BY score DESC, search_matches.times_played DESC                                                                                                          +
   LIMIT p_max_results;                                                                                                                                           +
 END;                                                                                                                                                             +
 $function$                                                                                                                                                       +
 
(1 row)

                                                                                       pg_get_functiondef                                                                                       
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.search_shows_with_songs_v3(search_songs text[], is_segue boolean DEFAULT false, song_ids uuid[] DEFAULT NULL::uuid[], venue_ids uuid[] DEFAULT NULL::uuid[])+
  RETURNS TABLE(show_id uuid, show_slug text, show_date text, venue_name text, venue_city text, venue_state text, venue_country text, match_score integer, match_details text)                 +
  LANGUAGE plpgsql                                                                                                                                                                             +
 AS $function$                                                                                                                                                                                 +
 BEGIN                                                                                                                                                                                         +
   RETURN QUERY                                                                                                                                                                                +
   WITH filtered_shows AS (                                                                                                                                                                    +
     -- BASE FILTER: Only shows at matching venues (if venue_ids provided)                                                                                                                     +
     SELECT s.id, s.slug, s.date, s.venue_id                                                                                                                                                   +
     FROM shows s                                                                                                                                                                              +
     WHERE venue_ids IS NULL OR s.venue_id = ANY(venue_ids)                                                                                                                                    +
   ),                                                                                                                                                                                          +
   filtered_tracks AS (                                                                                                                                                                        +
     -- BASE FILTER: Only tracks with matching songs (if song_ids provided) at filtered shows                                                                                                  +
     SELECT                                                                                                                                                                                    +
       t.show_id,                                                                                                                                                                              +
       t.id as track_id,                                                                                                                                                                       +
       t.position,                                                                                                                                                                             +
       t.set,                                                                                                                                                                                  +
       t.segue,                                                                                                                                                                                +
       t.next_track_id,                                                                                                                                                                        +
       t.note,                                                                                                                                                                                 +
       s.title as song_title,                                                                                                                                                                  +
       s.id as song_id,                                                                                                                                                                        +
       LOWER(s.title) as song_lower,                                                                                                                                                           +
       -- Context: previous and next songs                                                                                                                                                     +
       LAG(s2.title) OVER (PARTITION BY t.show_id ORDER BY t.position) as prev_song,                                                                                                           +
       LEAD(s3.title) OVER (PARTITION BY t.show_id ORDER BY t.position) as next_song,                                                                                                          +
       LAG(t2.segue) OVER (PARTITION BY t.show_id ORDER BY t.position) as prev_segue                                                                                                           +
     FROM tracks t                                                                                                                                                                             +
     JOIN songs s ON t.song_id = s.id                                                                                                                                                          +
     JOIN filtered_shows fs ON t.show_id = fs.id                                                                                                                                               +
     LEFT JOIN tracks t2 ON t2.next_track_id = t.id  -- Previous track                                                                                                                         +
     LEFT JOIN songs s2 ON t2.song_id = s2.id        -- Previous song                                                                                                                          +
     LEFT JOIN tracks t3 ON t.next_track_id = t3.id  -- Next track                                                                                                                             +
     LEFT JOIN songs s3 ON t3.song_id = s3.id        -- Next song                                                                                                                              +
     WHERE song_ids IS NULL OR t.song_id = ANY(song_ids)                                                                                                                                       +
   ),                                                                                                                                                                                          +
   matched_tracks AS (                                                                                                                                                                         +
     -- Find tracks that match search terms (after base filtering)                                                                                                                             +
     SELECT                                                                                                                                                                                    +
       ft.*,                                                                                                                                                                                   +
       -- Score based on text matching quality (not entity IDs - those are already filtered)                                                                                                   +
       CASE                                                                                                                                                                                    +
         WHEN song_ids IS NOT NULL THEN 100  -- Exact entity match (already filtered above)                                                                                                    +
         WHEN EXISTS (                                                                                                                                                                         +
           SELECT 1 FROM unnest(search_songs) AS ss                                                                                                                                            +
           WHERE ft.song_lower LIKE '%' || LOWER(ss) || '%'                                                                                                                                    +
         ) THEN 70  -- Text match within filtered results                                                                                                                                      +
         WHEN ft.song_lower LIKE '%' || LOWER(array_to_string(search_songs, ' ')) || '%' THEN 50                                                                                               +
         ELSE 30  -- Fallback match                                                                                                                                                            +
       END as song_match_score,                                                                                                                                                                +
       -- Mark entity matches for frontend highlighting                                                                                                                                        +
       CASE WHEN song_ids IS NOT NULL THEN true ELSE false END as is_exact_match                                                                                                               +
     FROM filtered_tracks ft                                                                                                                                                                   +
     WHERE                                                                                                                                                                                     +
       -- If we have song_ids, we already filtered above, so include all                                                                                                                       +
       song_ids IS NOT NULL                                                                                                                                                                    +
       OR                                                                                                                                                                                      +
       -- If no song_ids, do text matching                                                                                                                                                     +
       (song_ids IS NULL AND (                                                                                                                                                                 +
         EXISTS (                                                                                                                                                                              +
           SELECT 1 FROM unnest(search_songs) AS ss                                                                                                                                            +
           WHERE ft.song_lower LIKE '%' || LOWER(ss) || '%'                                                                                                                                    +
         )                                                                                                                                                                                     +
         OR ft.song_lower LIKE '%' || LOWER(array_to_string(search_songs, ' ')) || '%'                                                                                                         +
       ))                                                                                                                                                                                      +
   ),                                                                                                                                                                                          +
   segue_matches AS (                                                                                                                                                                          +
     -- Find segue patterns in the matched tracks                                                                                                                                              +
     SELECT DISTINCT                                                                                                                                                                           +
       mt1.show_id AS match_show_id,                                                                                                                                                           +
       json_build_object(                                                                                                                                                                      +
         'type', 'segue',                                                                                                                                                                      +
         'song1', mt1.song_title,                                                                                                                                                              +
         'song2', mt2.song_title,                                                                                                                                                              +
         'segueSymbol', mt1.segue,                                                                                                                                                             +
         'set', mt1.set,                                                                                                                                                                       +
         'positions', array[mt1.position, mt2.position],                                                                                                                                       +
         'note1', mt1.note,                                                                                                                                                                    +
         'note2', mt2.note,                                                                                                                                                                    +
         'exactMatches', array[mt1.is_exact_match, mt2.is_exact_match]                                                                                                                         +
       )::text as context_data,                                                                                                                                                                +
       -- Higher scores for better matches                                                                                                                                                     +
       CASE                                                                                                                                                                                    +
         WHEN mt1.is_exact_match AND mt2.is_exact_match THEN 150                                                                                                                               +
         WHEN mt1.is_exact_match OR mt2.is_exact_match THEN 120                                                                                                                                +
         ELSE 100                                                                                                                                                                              +
       END as segue_score                                                                                                                                                                      +
     FROM matched_tracks mt1                                                                                                                                                                   +
     JOIN matched_tracks mt2 ON mt1.next_track_id = mt2.track_id                                                                                                                               +
     WHERE mt1.segue = '>'                                                                                                                                                                     +
       AND mt1.show_id = mt2.show_id                                                                                                                                                           +
       AND is_segue                                                                                                                                                                            +
       AND array_length(search_songs, 1) = 2                                                                                                                                                   +
   ),                                                                                                                                                                                          +
   show_matches AS (                                                                                                                                                                           +
     SELECT                                                                                                                                                                                    +
       COALESCE(sm.match_show_id, mt.show_id) AS match_show_id,                                                                                                                                +
       -- Scoring: entity matches get base score, venue matches get bonus                                                                                                                      +
       CASE                                                                                                                                                                                    +
         WHEN sm.match_show_id IS NOT NULL THEN sm.segue_score                                                                                                                                 +
         ELSE GREATEST(50, MAX(mt.song_match_score))                                                                                                                                           +
       END +                                                                                                                                                                                   +
       -- Venue bonus (only when not already filtered by venue_ids)                                                                                                                            +
       CASE                                                                                                                                                                                    +
         WHEN venue_ids IS NOT NULL THEN 50  -- Bonus for being in target venues                                                                                                               +
         ELSE 0                                                                                                                                                                                +
       END as final_score,                                                                                                                                                                     +
       -- Context data for frontend (using camelCase)                                                                                                                                          +
       COALESCE(                                                                                                                                                                               +
         sm.context_data,                                                                                                                                                                      +
         json_build_object(                                                                                                                                                                    +
           'type', 'trackMatches',                                                                                                                                                             +
           'tracks', json_agg(                                                                                                                                                                 +
             json_build_object(                                                                                                                                                                +
               'song', mt.song_title,                                                                                                                                                          +
               'position', mt.position,                                                                                                                                                        +
               'set', mt.set,                                                                                                                                                                  +
               'note', mt.note,                                                                                                                                                                +
               'prevSong', mt.prev_song,                                                                                                                                                       +
               'nextSong', mt.next_song,                                                                                                                                                       +
               'prevSegue', mt.prev_segue,                                                                                                                                                     +
               'nextSegue', mt.segue,                                                                                                                                                          +
               'isExactMatch', mt.is_exact_match,                                                                                                                                              +
               'isOpener', CASE WHEN mt.position = 1 THEN true ELSE false END,                                                                                                                 +
               'isCloser', CASE WHEN mt.next_track_id IS NULL THEN true ELSE false END                                                                                                         +
             ) ORDER BY mt.position                                                                                                                                                            +
           )                                                                                                                                                                                   +
         )::text                                                                                                                                                                               +
       ) as match_details                                                                                                                                                                      +
     FROM matched_tracks mt                                                                                                                                                                    +
     LEFT JOIN segue_matches sm ON mt.show_id = sm.match_show_id                                                                                                                               +
     WHERE is_segue = false OR sm.match_show_id IS NOT NULL                                                                                                                                    +
     GROUP BY sm.match_show_id, mt.show_id, sm.context_data, sm.segue_score                                                                                                                    +
   )                                                                                                                                                                                           +
   SELECT                                                                                                                                                                                      +
     sm.match_show_id,                                                                                                                                                                         +
     sh.slug::TEXT,                                                                                                                                                                            +
     sh.date::TEXT,                                                                                                                                                                            +
     v.name::TEXT,                                                                                                                                                                             +
     v.city::TEXT,                                                                                                                                                                             +
     v.state::TEXT,                                                                                                                                                                            +
     v.country::TEXT,                                                                                                                                                                          +
     sm.final_score::INTEGER,                                                                                                                                                                  +
     sm.match_details::TEXT                                                                                                                                                                    +
   FROM show_matches sm                                                                                                                                                                        +
   JOIN shows sh ON sm.match_show_id = sh.id                                                                                                                                                   +
   LEFT JOIN venues v ON sh.venue_id = v.id                                                                                                                                                    +
   ORDER BY sm.final_score DESC, sh.date DESC                                                                                                                                                  +
   LIMIT 50;                                                                                                                                                                                   +
 END;                                                                                                                                                                                          +
 $function$                                                                                                                                                                                    +
 
(1 row)

                                                   pg_get_functiondef                                                    
-------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.search_date_match(show_date text, query text)                                        +
  RETURNS boolean                                                                                                       +
  LANGUAGE plpgsql                                                                                                      +
 AS $function$                                                                                                          +
 DECLARE                                                                                                                +
   normalized_query TEXT;                                                                                               +
   query_date DATE;                                                                                                     +
   year_part TEXT;                                                                                                      +
 BEGIN                                                                                                                  +
   normalized_query := LOWER(TRIM(query));                                                                              +
                                                                                                                        +
   -- Direct date match (YYYY-MM-DD format)                                                                             +
   IF show_date = normalized_query THEN                                                                                 +
     RETURN TRUE;                                                                                                       +
   END IF;                                                                                                              +
                                                                                                                        +
   -- Try to parse various date formats                                                                                 +
   BEGIN                                                                                                                +
     -- Handle formats like: 12/30/99, 12-30-99, 12.30.99                                                               +
     IF normalized_query ~ '^\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{2}$' THEN                                                   +
       -- Extract the year part                                                                                         +
       year_part := SUBSTRING(normalized_query FROM '\d{2}$');                                                          +
       -- Add century for 2-digit years (assume 20xx for 00-30, 19xx for 31-99)                                         +
       IF year_part::INT <= 30 THEN                                                                                     +
         normalized_query := REGEXP_REPLACE(normalized_query, '(\d{1,2})[/\-\.](\d{1,2})[/\-\.](\d{2})$', '20\3-\1-\2');+
       ELSE                                                                                                             +
         normalized_query := REGEXP_REPLACE(normalized_query, '(\d{1,2})[/\-\.](\d{1,2})[/\-\.](\d{2})$', '19\3-\1-\2');+
       END IF;                                                                                                          +
       query_date := normalized_query::DATE;                                                                            +
                                                                                                                        +
     -- Handle formats like: 12/30/1999, 12-30-1999                                                                     +
     ELSIF normalized_query ~ '^\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{4}$' THEN                                                +
       normalized_query := REGEXP_REPLACE(normalized_query, '(\d{1,2})[/\-\.](\d{1,2})[/\-\.](\d{4})$', '\3-\1-\2');    +
       query_date := normalized_query::DATE;                                                                            +
                                                                                                                        +
     -- Handle formats like: "dec 30 1999", "december 30, 1999"                                                         +
     ELSIF normalized_query ~ '(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)' THEN                                  +
       query_date := normalized_query::DATE;                                                                            +
                                                                                                                        +
     -- Handle formats like: "30 dec 1999"                                                                              +
     ELSIF normalized_query ~ '^\d{1,2}\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)' THEN                       +
       query_date := normalized_query::DATE;                                                                            +
                                                                                                                        +
     ELSE                                                                                                               +
       -- Try PostgreSQL's date parser as last resort                                                                   +
       query_date := normalized_query::DATE;                                                                            +
     END IF;                                                                                                            +
                                                                                                                        +
     -- Compare parsed date with show date                                                                              +
     RETURN show_date::DATE = query_date;                                                                               +
                                                                                                                        +
   EXCEPTION WHEN OTHERS THEN                                                                                           +
     -- If date parsing fails, try partial matching                                                                     +
     -- Handle partial dates like "december 1999" or "12/99"                                                            +
     IF normalized_query ~ '^\d{1,2}[/\-]\d{2,4}$' THEN                                                                 +
       -- Month/Year search                                                                                             +
       RETURN show_date LIKE '%' || SUBSTR(normalized_query, 1, 2) || '%';                                              +
     ELSIF normalized_query ~ '^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*\d{4}$' THEN                         +
       -- "December 1999" style - check if show is in that month                                                        +
       RETURN show_date::DATE >= (normalized_query || ' 01')::DATE                                                      +
          AND show_date::DATE <= ((normalized_query || ' 01')::DATE + INTERVAL '1 month - 1 day');                      +
     ELSE                                                                                                               +
       -- Fallback to pattern matching                                                                                  +
       RETURN show_date ILIKE '%' || normalized_query || '%';                                                           +
     END IF;                                                                                                            +
   END;                                                                                                                 +
 END;                                                                                                                   +
 $function$                                                                                                             +
 
(1 row)

